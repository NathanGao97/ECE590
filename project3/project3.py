"""
Math 560
Project 3
Fall 2021

Partner 1: Zedong Gao (zg79)
Partner 2: Yunbo Liu (yl815)
Date: 11/07/2021
"""

# Import math and p3tests.
import math
from p3tests import *

################################################################################

"""
detectArbitrage function will provide a single list of vertex ranks representing the negative cost cycle.

INPUTS
adjList: the adjacency list representing the currencies graph.
adjMat: the adjacency matrix representing the exchange rates, as generated by the rates2mat function.
tol: this is a value that is set at 1e-15 as default, and should not be altered.

OUTPUTS
path: a single list of vertex ranks representing the negative cost cycle.
"""
def detectArbitrage(adjList, adjMat, tol=1e-15):
    # Set initial dist and prev.
    for vertex in adjList:
        vertex.dist = math.inf  # Infinite dist initially.
        vertex.prev = None  # No previous node on path yet.
    adjList[0].dist = 0  # The dist of start vertex is 0.
    # Iterate |V| - 1 times.
    for iter in range(len(adjList) - 1):
        # Look at each vertex.
        for u in adjList:
            # Check each neighbour of u.
            # Update predictions and previous vertex.
            for neigh in u.neigh:
                # Only update if the new value is better.
                # Take tol into consideration to deal with machine epsilon.
                if neigh.dist > u.dist + adjMat[u.rank][neigh.rank] + tol:
                    neigh.dist = u.dist + adjMat[u.rank][neigh.rank]
                    neigh.prev = u

    disList = []
    # Store the dist of each vertex after |V| - 1 iterations.
    for u in adjList:
        disList.append(u.dist)

    # Iterate on more time to find a possible negative cost cycle.
    for u in adjList:
        for neigh in u.neigh:
            if neigh.dist > u.dist + adjMat[u.rank][neigh.rank] + tol:
                neigh.dist = u.dist + adjMat[u.rank][neigh.rank]
                neigh.prev = u

    changedVertex = []
    # Store every vertex whose dist has changed during the one extra iteration.
    for i in range(len(adjList)):
        # Compare the current dist to that before the one extra iteration.
        # If the dist has changed, store the corresponding vertex.
        if adjList[i].dist < disList[i]:
            changedVertex.append(adjList[i])

    # No negative cost cycle.
    if len(changedVertex) == 0:
        return []
    # Negative cost cycle exists.
    else:
        # Choose the first vertex in changedVertex and follow its path backwards until a cycle is found.
        path = [changedVertex[0].rank]
        pre = changedVertex[0].prev
        end = False
        # Visit and store the previous vertex iteratively until meet a passed vertex.
        while pre:
            path.append(pre.rank)
            pre = pre.prev
            for i in range(len(path)):
                if pre.rank == path[i]:
                    end = True
                    break
            if end:
                break
        path.append(pre.rank)

        # Reverse the list to get a correct order and get a path forwards.
        path.reverse()

        # Remove any vertices that are not part of the cycle.
        index = 0
        for i in range(1, len(path)):
            if path[i] == path[0]:
                index = i
                break
        # Get the cycle.
        path = path[:index + 1]
        return path  # Return the list representing a negative cost cycle with path forwards.


"""
rates2mat function to create the adjacency matrix given the exchange rates between currencies. 

INPUTS
rates: A 2D list of the different exchange rates.

OUTPUTS
The adjacency matrix for the graph.
"""
def rates2mat(rates):
    # We use -log(1/exchange rates) to represent weights of edges in the adjacency matrix between currencies.
    # It makes sense to add edges together, which represents exchange between currencies.
    # Therefore, Bellman-Ford could be applied here to find a negative cost cycle.
    return [[-math.log(R) for R in row] for row in rates]


"""
Main function.
"""
if __name__ == "__main__":
    testRates()